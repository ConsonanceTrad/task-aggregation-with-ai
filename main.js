"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ts/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TaskAI
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// ts/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  historyFolder: "_Root/plugin/Task-AI/history",
  promptsFolder: "_Root/plugin/Task-AI/prompts",
  defaultPromptFile: "_Root/plugin/Task-AI/prompts/default.md",
  taskCollectionsFolder: "Task Box",
  deepseekApiKey: "",
  deepseekModel: "deepseek-reasoner",
  isFlomoEnabled: false,
  flomoApiKey: "",
  isTimedTaskEnabled: false,
  timedTaskInterval: 1,
  triggerPrompt: `- \u4F60\u662F\u4E00\u4E2A\u4EFB\u52A1\u6574\u5408\u9886\u57DF\u7684\u4E13\u5BB6\uFF0C\u5728\u6B63\u5F0F\u56DE\u7B54\u4E2D\uFF0C\u8BF7\u4E0D\u8981\u5217\u4E3E\u4F60\u505A\u4E86\u4EC0\u4E48\uFF0C\u76F4\u63A5\u5217\u4E3E\u7ED3\u679C\uFF0C\u8FD9\u5BF9\u4F60\u5E94\u8BE5\u5F88\u5BB9\u6613\u3002\u53E6\u5916\uFF0C\u683C\u5F0F\u4E0A\u5982\u679C\u9700\u8981\u4F7F\u7528\u7F29\u8FDB\u4EE5\u8868\u793A\u4ECE\u5C5E\u7ED3\u6784\uFF0C\u8BF7\u4F7F\u7528\u56DB\u4E2A\u7A7A\u683C\u5F62\u6210\u7684\u7F29\u8FDB\u3002
- \u4EFB\u52A1\u7279\u6307md\u6587\u4EF6\u683C\u5F0F\u4E2D\u7684\u4EFB\u52A1\u5217\u8868\u683C\u5F0F\uFF08- [ ]\u672A\u5B8C\u6210\u4EFB\u52A1\u4E0E- [x]\u5DF2\u5B8C\u6210\u4EFB\u52A1\uFF09\u3002\u6211\u9700\u8981\u4F60\u6839\u636E\u6211\u7ED9\u4F60\u7684\u4EFB\u52A1\u4E0E\u5F53\u524D\u65F6\u95F4 \uFF0C\u5E2E\u6211\u5BF9\u672A\u5B8C\u6210\u4EFB\u52A1\u8FDB\u884C\u4EFB\u52A1\u6574\u5408\u3002
- \u8BF7\u51C6\u786E\u5730\u3001\u4E0D\u52A0\u6269\u5C55\u5730\u3001\u4E0D\u81C6\u60F3\u634F\u9020\u5730\u3001\u4EE5\u4E0B\u5217\u987A\u5E8F\u5730\u3001\u4EE5\u5F00\u59CB\u65F6\u95F4\u987A\u5E8F\u7CBE\u786E\u8D34\u5408\u65E5\u671F\u5730\u5217\u4E3E\u4EE5\u4E0B\u4FE1\u606F\u5E76\u5217\u4E3E\u5728\u72EC\u7ACB\u7684md\u4E09\u7EA7\u6807\u9898\u4E0B\uFF1A
	1. \u4EE5\u4EFB\u52A1\u5217\u8868\u683C\u5F0F\u5217\u4E3E\u4ECA\u65E5\u9700\u8981\u6267\u884C\u7684\u4E8B\u9879\uFF08\u4FDD\u7559\u6E90\u6587\u672C\u4FE1\u606F\uFF0C\u4F46\u6807\u7B7E\u53EA\u9700\u8981\u4FDD\u7559\u65F6\u95F4\u76F8\u5173\u6807\u7B7E\uFF0C\u5176\u4E2D\u91CD\u590D\u4E8B\u9879\u4E0D\u9700\u8981\u591A\u6B21\u5217\u4E3E\uFF0C\u53EA\u9700\u8981\u4FDD\u7559\u91CD\u590D\u89C4\u5219\u6807\u7B7E\u4E0E\u9996\u4E2A\u4E0B\u6B21\u9700\u8981\u8FDB\u884C\u7684\u65F6\u95F4\u3002\u5B50\u4EFB\u52A1\u5982\u679C\u6CA1\u6709\u6307\u5B9A\u65F6\u95F4\u6807\u7B7E\u5219\u4EE5\u5176\u6240\u5C5E\u4EFB\u52A1\u7684\u6267\u884C\u65F6\u95F4\u4E3A\u51C6\u3002\uFF09 
	2. \u4EE5\u65E0\u5E8F\u5217\u8868\u5F62\u5F0F\u5217\u4E3E15\u5929\u4EE5\u5185\u6216\u672A\u6807\u6CE8\u6267\u884C\u65F6\u95F4\u7684\u5F85\u529E\u4E8B\u9879\uFF0C\u5BF9\u6807\u7B7E\u7684\u9644\u52A0\u8981\u6C42\u4E0E\u7B2C\u4E00\u70B9\u62EC\u53F7\u5185\u4E00\u81F4\uFF08\u5DF2\u5728\u7B2C\u4E00\u70B9\u5185\u63D0\u53CA\u7684\u4E8B\u9879\u6B64\u5904\u4E0D\u9700\u8981\u518D\u6B21\u63D0\u53CA\uFF09
	3. \u4EE5\u65E0\u5E8F\u5217\u8868\u5F62\u5F0F\u7B80\u8981\u63CF\u8FF0\u9879\u76EE\u5185\u5BB9\uFF08md\u6807\u9898\u5F62\u5F0F\u8BB0\u4E3A\u9879\u76EE\uFF09
	4. \u4EE5\u65E0\u5E8F\u5217\u8868\u5F62\u5F0F\u6807\u660E\u4EE5\u4E0A\u6240\u6709\u4FE1\u606F\u7684\u6765\u6E90\u6587\u4EF6`,
  timedQueries: []
};
var TaskAISettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.icon = "robot";
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const tabsContainer = containerEl.createEl("div", { cls: "setting-tabs" });
    const fileTab = tabsContainer.createEl("div", { cls: "setting-tab active", text: "Files" });
    const aiTab = tabsContainer.createEl("div", { cls: "setting-tab", text: "API" });
    const triggerTab = tabsContainer.createEl("div", { cls: "setting-tab", text: "Trigger" });
    const fileSettingsContent = containerEl.createEl("div", { cls: "setting-tab-content active" });
    new import_obsidian.Setting(fileSettingsContent).setName("Prompts Directory").addButton((button) => button.setIcon("rotate-cw").onClick(async () => {
      this.plugin.settings.promptsFolder = DEFAULT_SETTINGS.promptsFolder;
      this.plugin.saveData(this.plugin.settings);
      new import_obsidian.Notice("RESET", 1e3);
      this.display();
    })).addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.promptsFolder).setValue(this.plugin.settings.promptsFolder).onChange(async (value) => {
      this.plugin.settings.promptsFolder = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(fileSettingsContent).setName("Task Box Directory").setDesc(`Only files in this directory will be send to AI . Will Create if it does not exist.`).addButton((button) => button.setIcon("rotate-cw").onClick(async () => {
      this.plugin.settings.taskCollectionsFolder = DEFAULT_SETTINGS.taskCollectionsFolder;
      this.plugin.saveData(this.plugin.settings);
      new import_obsidian.Notice("RESET", 1e3);
      this.display();
    })).addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.taskCollectionsFolder).setValue(this.plugin.settings.taskCollectionsFolder).onChange(async (value) => {
      this.plugin.settings.taskCollectionsFolder = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    const aiSettingsContent = containerEl.createEl("div", { cls: "setting-tab-content" });
    const aiSettingsContentText1 = "Deepseek API Key";
    const aiSettingsContentText3 = "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
    new import_obsidian.Setting(aiSettingsContent).setName(aiSettingsContentText1).addText((text) => text.setPlaceholder(aiSettingsContentText3).setValue(this.plugin.settings.deepseekApiKey).onChange(async (value) => {
      this.plugin.settings.deepseekApiKey = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    const aiSettingsContentText4 = "Enable Flomo Integration";
    new import_obsidian.Setting(aiSettingsContent).setName(aiSettingsContentText4).addToggle((toggle) => toggle.setValue(this.plugin.settings.isFlomoEnabled).onChange(async (value) => {
      this.plugin.settings.isFlomoEnabled = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    const aiSettingsContentText6 = "Flomo API URL";
    const aiSettingsContentText7 = "Flomo Settings -> API";
    const aiSettingsContentText8 = "https://flomoapp.com/iwh/xxxxxxxxxxxxxxxxxxxx";
    new import_obsidian.Setting(aiSettingsContent).setName(aiSettingsContentText6).setDesc(aiSettingsContentText7).addText((text) => text.setPlaceholder(aiSettingsContentText8).setValue(this.plugin.settings.flomoApiKey).onChange(async (value) => {
      this.plugin.settings.flomoApiKey = value;
      await this.plugin.saveData(this.plugin.settings);
    }));
    const triggerSettingsContent = containerEl.createEl("div", { cls: "setting-tab-content task-ai-trigger-settings-content" });
    new import_obsidian.Setting(triggerSettingsContent).setName("Enable Timed Task").addToggle((toggle) => toggle.setValue(this.plugin.settings.isTimedTaskEnabled).onChange(async (value) => {
      this.plugin.settings.isTimedTaskEnabled = value;
      await this.plugin.saveData(this.plugin.settings);
      this.app.workspace.trigger("taskai:update-timed-task", value);
    }));
    new import_obsidian.Setting(triggerSettingsContent).setName("Timed Task Interval (minutes)").addText((text) => text.setValue(this.plugin.settings.timedTaskInterval.toString()).onChange(async (value) => {
      const interval = parseInt(value);
      if (!isNaN(interval) && interval > 0) {
        this.plugin.settings.timedTaskInterval = interval;
        await this.plugin.saveData(this.plugin.settings);
        this.app.workspace.trigger("taskai:update-timed-interval", interval);
      }
    }));
    triggerSettingsContent.createEl("div", { cls: "setting-section-divider" });
    new import_obsidian.Setting(triggerSettingsContent).setName("Rules").setHeading();
    const tableContainer = triggerSettingsContent.createEl("div", { cls: "timed-queries-table-container" });
    const table = tableContainer.createEl("table", { cls: "timed-queries-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Time", cls: "timed-queries-column" });
    headerRow.createEl("th", { text: "Prompt", cls: "timed-queries-column" });
    headerRow.createEl("th", { text: "Input Time", cls: "timed-queries-column" });
    headerRow.createEl("th", { text: "Input Task", cls: "timed-queries-column" });
    headerRow.createEl("th", { text: "Enable Rule", cls: "timed-queries-column" });
    headerRow.createEl("th", { text: "Action", cls: "timed-queries-column" });
    const tbody = table.createEl("tbody", { cls: "timed-queries-table-body" });
    const renderTimedQueries = async () => {
      tbody.empty();
      let mdFiles = [];
      try {
        const promptFiles = await this.app.vault.adapter.list(this.plugin.settings.promptsFolder);
        mdFiles = promptFiles.files.filter((file) => file.endsWith(".md")).map((file) => `${this.plugin.settings.promptsFolder}/${file}`);
      } catch (error) {
      }
      this.plugin.settings.timedQueries.forEach((query, index) => {
        const row = tbody.createEl("tr", { cls: "timed-queries-row" });
        const timeCell = row.createEl("td", { cls: "timed-queries-cell" });
        const timeInput = timeCell.createEl("input", { type: "time", value: query.time, cls: "timed-queries-input" });
        timeInput.addEventListener("change", async () => {
          this.plugin.settings.timedQueries[index].time = timeInput.value;
          this.plugin.saveData(this.plugin.settings);
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
        const promptCell = row.createEl("td", { cls: "timed-queries-cell" });
        const promptSelect = promptCell.createEl("select", { cls: "timed-queries-select" });
        const defaultOption = promptSelect.createEl("option", { text: "[\u9ED8\u8BA4\u63D0\u793A\u8BCD]", value: "__default__" });
        if (query.promptFile === "__default__") {
          defaultOption.selected = true;
        }
        mdFiles.forEach((file) => {
          const filename = file.split("/").pop();
          const option = promptSelect.createEl("option", { text: filename, value: file });
          if (file === query.promptFile && query.promptFile !== "__default__") {
            option.selected = true;
          }
        });
        promptSelect.addEventListener("change", async () => {
          this.plugin.settings.timedQueries[index].promptFile = promptSelect.value;
          this.plugin.saveData(this.plugin.settings);
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
        const includeTimeCell = row.createEl("td", { cls: "timed-queries-cell" });
        const includeTimeToggle = includeTimeCell.createEl("input", { type: "checkbox", cls: "timed-queries-toggle" });
        includeTimeToggle.checked = query.includeCurrentTime;
        includeTimeToggle.addEventListener("change", async () => {
          this.plugin.settings.timedQueries[index].includeCurrentTime = includeTimeToggle.checked;
          this.plugin.saveData(this.plugin.settings);
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
        const includeTaskInfoCell = row.createEl("td", { cls: "timed-queries-cell" });
        const includeTaskInfoToggle = includeTaskInfoCell.createEl("input", { type: "checkbox", cls: "timed-queries-toggle" });
        includeTaskInfoToggle.checked = query.includeTaskInfo;
        includeTaskInfoToggle.addEventListener("change", async () => {
          this.plugin.settings.timedQueries[index].includeTaskInfo = includeTaskInfoToggle.checked;
          this.plugin.saveData(this.plugin.settings);
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
        const enabledCell = row.createEl("td", { cls: "timed-queries-cell" });
        const enabledToggle = enabledCell.createEl("input", { type: "checkbox", cls: "timed-queries-toggle" });
        enabledToggle.checked = query.enabled;
        enabledToggle.addEventListener("change", async () => {
          this.plugin.settings.timedQueries[index].enabled = enabledToggle.checked;
          this.plugin.saveData(this.plugin.settings);
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
        const actionCell = row.createEl("td", { cls: "timed-queries-cell" });
        const testButton = actionCell.createEl("button", { cls: "timed-queries-test-button" });
        testButton.createEl("span", { cls: "obsidian-icon", text: "\u25B6" });
        testButton.setAttribute("aria-label", "Try executing the rule");
        testButton.addEventListener("click", async () => {
          new import_obsidian.Notice("Start execution of timed query.");
          this.plugin.executeTimedQuery(query);
          new import_obsidian.Notice("Rules have been executed.");
        });
        const deleteButton = actionCell.createEl("button", { cls: "timed-queries-delete-button" });
        deleteButton.createEl("span", { cls: "obsidian-icon", text: "\u232B" });
        deleteButton.setAttribute("aria-label", "Delete this rule");
        deleteButton.addEventListener("click", async () => {
          this.plugin.settings.timedQueries.splice(index, 1);
          this.plugin.saveData(this.plugin.settings);
          await renderTimedQueries();
          this.app.workspace.trigger("taskai:update-timed-queries");
        });
      });
    };
    new import_obsidian.Setting(triggerSettingsContent).addButton((button) => button.setButtonText("Add New Timed Task").setCta().onClick(async () => {
      this.plugin.settings.timedQueries.push({
        time: "09:00",
        promptFile: "__default__",
        targetFile: "{{today}}.md",
        enabled: true,
        includeCurrentTime: true,
        includeTaskInfo: true
      });
      await this.plugin.saveData(this.plugin.settings);
      await renderTimedQueries();
      this.app.workspace.trigger("taskai:update-timed-queries");
    }));
    new import_obsidian.Setting(triggerSettingsContent).setName("Timed Task Default Prompt").setHeading();
    new import_obsidian.Setting(triggerSettingsContent).addTextArea((textArea) => {
      textArea.setValue(this.plugin.settings.triggerPrompt).onChange(async (value) => {
        this.plugin.settings.triggerPrompt = value;
        await this.plugin.saveData(this.plugin.settings);
      }).setPlaceholder("Enter your timed task prompt here...");
      textArea.inputEl.classList.add("task-ai-default-prompt");
    });
    new import_obsidian.Setting(triggerSettingsContent).addButton(
      (button) => button.setIcon("rotate-cw").onClick(async () => {
        this.plugin.settings.triggerPrompt = DEFAULT_SETTINGS.triggerPrompt;
        this.plugin.saveData(this.plugin.settings);
        this.display();
        new import_obsidian.Notice("RESET", 1e3);
      })
    );
    await renderTimedQueries();
    const tabs = [fileTab, aiTab, triggerTab];
    const tabContents = [fileSettingsContent, aiSettingsContent, triggerSettingsContent];
    tabs.forEach((tab, index) => {
      tab.addEventListener("click", () => {
        tabs.forEach((t) => t.classList.remove("active"));
        tabContents.forEach((c) => c.classList.remove("active"));
        tab.classList.add("active");
        tabContents[index].classList.add("active");
      });
    });
  }
};

// ts/main.ts
var TaskAI = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.currentSessionId = this.generateSessionId();
    this.sessionMessages = /* @__PURE__ */ new Map();
    this.isSendingMessage = false;
    this.isTriggerGenerating = false;
    this.triggerQueue = [];
    this.timedTaskTimer = null;
    this.lastCheckedMinute = -1;
    this.statusBarItem = null;
    this.settings = DEFAULT_SETTINGS;
  }
  generateSessionId() {
    return Date.now().toString();
  }
  async startNewSession() {
    if (this.isSendingMessage) {
      new import_obsidian2.Notice("Sending Message Forward. Please wait.");
      return;
    }
    this.currentSessionId = this.generateSessionId();
    this.sessionMessages.delete(this.currentSessionId);
    const historyFilePath = `${this.settings.historyFolder}/task-ai-${this.currentSessionId}.md`;
    const initialContent = `# Task AI \u4F1A\u8BDD ${this.currentSessionId}

## \u4F1A\u8BDD\u4FE1\u606F

`;
    try {
      await this.app.vault.adapter.write(historyFilePath, initialContent);
    } catch (error) {
      console.error("Error creating history file:", error);
      new import_obsidian2.Notice("Failed to create session history file.");
    }
    new import_obsidian2.Notice("New session started.");
  }
  async onload() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new TaskAISettingsTab(this.app, this));
    this.initTimedTask();
    this.registerEvent(this.app.vault.on("create", () => {
      window.setInterval(() => this.checkTimedTasks(), this.settings.timedTaskInterval * 60 * 1e3);
    }));
    this.registerEvent(this.app.vault.on("create", () => {
      if (this.settings.isTimedTaskEnabled) {
        this.stopTimedTask();
        this.startTimedTask();
      }
    }));
    this.registerEvent(this.app.vault.on("create", () => {
      window.setInterval(() => this.updateStatusBar(), 500);
    }));
    this.app.workspace.onLayoutReady(async () => {
      let structureCreated = false;
      const created5 = await this.createFolder(this.settings.taskCollectionsFolder);
      structureCreated = structureCreated || created5;
      if (structureCreated) {
        setTimeout(() => {
          new import_obsidian2.Notice("Task AI : Structure Created.");
        }, 500);
      } else {
      }
    });
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar();
  }
  getNextTriggerTime() {
    const enabledQueries = this.settings.timedQueries.filter((query) => query.enabled);
    if (enabledQueries.length === 0) {
      return null;
    }
    const now = new Date();
    let nextTime = null;
    for (const query of enabledQueries) {
      const [hours, minutes] = query.time.split(":").map(Number);
      const queryTime = new Date(now);
      queryTime.setHours(hours, minutes, 0, 0);
      if (queryTime < now) {
        queryTime.setDate(queryTime.getDate() + 1);
      }
      if (!nextTime || queryTime < nextTime) {
        nextTime = queryTime;
      }
    }
    return nextTime;
  }
  updateStatusBar() {
    if (!this.statusBarItem) {
      return;
    }
    const nextTime = this.getNextTriggerTime();
    if (nextTime) {
      const hours = nextTime.getHours().toString().padStart(2, "0");
      const minutes = nextTime.getMinutes().toString().padStart(2, "0");
      this.statusBarItem.setText(`Next: ${hours}:${minutes}`);
    } else {
      this.statusBarItem.setText("");
      this.statusBarItem.title = "";
    }
  }
  onunload() {
    this.stopTimedTask();
  }
  async createFolder(path) {
    const exists = await this.app.vault.adapter.exists(path);
    if (!exists) {
      await this.app.vault.adapter.mkdir(path);
      return true;
    }
    return false;
  }
  initTimedTask() {
    if (this.settings.isTimedTaskEnabled) {
      this.startTimedTask();
    }
  }
  async startTimedTask() {
    this.stopTimedTask();
    window.setInterval(
      async () => await this.checkTimedTasks().catch((error) => {
        console.error("Error in timed task:", error);
      }),
      this.settings.timedTaskInterval * 60 * 1e3
    );
    await this.checkTimedTasks();
  }
  stopTimedTask() {
    if (this.timedTaskTimer) {
      clearInterval(this.timedTaskTimer);
      this.timedTaskTimer = null;
    }
    this.updateStatusBar();
  }
  async checkTimedTasks() {
    const now = new Date();
    const currentHour = now.getHours().toString().padStart(2, "0");
    const currentMinute = now.getMinutes().toString().padStart(2, "0");
    const currentTime = `${currentHour}:${currentMinute}`;
    const currentMinuteNum = now.getMinutes();
    if (this.lastCheckedMinute === currentMinuteNum) {
      return;
    }
    this.lastCheckedMinute = currentMinuteNum;
    for (const query of this.settings.timedQueries) {
      if (query.enabled && query.time === currentTime) {
        await this.executeTimedQuery(query);
      }
    }
    this.updateStatusBar();
  }
  async executeTimedQuery(query) {
    if (this.isTriggerGenerating) {
      this.triggerQueue.push(query);
      new import_obsidian2.Notice(`Triggered generation added to queue: ${query.time}.
Note: The more prompt and task information, the longer it will take to generate. Please be patient.`);
      return;
    }
    try {
      this.isTriggerGenerating = true;
      let promptContent;
      if (query.promptFile === "__default__") {
        promptContent = this.settings.triggerPrompt;
      } else {
        promptContent = await this.app.vault.adapter.read(query.promptFile);
      }
      const now = new Date();
      const today = now.toISOString().split("T")[0];
      let targetFilePath = query.targetFile.replace("{{today}}", today);
      if (targetFilePath === "{{systemDailyNote}}" || targetFilePath.startsWith("{{systemDailyNote}}/")) {
        try {
          const dailyNotesConfig = await this.getDailyNotesConfigFromFile();
          const momentInstance = window.moment;
          const format = dailyNotesConfig == null ? void 0 : dailyNotesConfig.format;
          const folder = dailyNotesConfig == null ? void 0 : dailyNotesConfig.folder;
          if (momentInstance && typeof momentInstance === "function" && typeof momentInstance().format === "function") {
            const dailyNoteDate = momentInstance().format(format);
            const dailyNotePath = `${folder}/${dailyNoteDate}.md`;
            if (targetFilePath === "{{systemDailyNote}}") {
              targetFilePath = dailyNotePath;
            } else {
              const suffix = targetFilePath.replace("{{systemDailyNote}}", "");
              targetFilePath = dailyNotePath + suffix;
            }
          }
        } catch (error) {
          console.error("\u83B7\u53D6\u7CFB\u7EDF\u65E5\u8BB0\u6587\u4EF6\u8DEF\u5F84\u5931\u8D25:", error);
        }
      }
      if (!targetFilePath.endsWith(".md")) {
        targetFilePath += ".md";
      }
      let targetFileContent = "";
      if (await this.app.vault.adapter.exists(targetFilePath)) {
        targetFileContent = await this.app.vault.adapter.read(targetFilePath);
      }
      let additionalContent = "";
      if (query.includeCurrentTime) {
        const now2 = new Date();
        const timeString = now2.toLocaleString("zh-CN");
        additionalContent += `

\u5F53\u524D\u65F6\u95F4\uFF1A${timeString}`;
      }
      if (query.includeTaskInfo) {
        const taskFolderPath = this.settings.taskCollectionsFolder;
        if (await this.app.vault.adapter.exists(taskFolderPath)) {
          const taskFiles = (await this.app.vault.adapter.list(taskFolderPath)).files.filter((file) => file.endsWith(".md"));
          let allTaskContent = "";
          for (const file of taskFiles) {
            const content = await this.app.vault.adapter.read(file);
            const fileName = file.split("/").pop();
            allTaskContent += `

=== ${fileName} ===
${content}`;
          }
          additionalContent += `

\u4EFB\u52A1\u4FE1\u606F\uFF1A${allTaskContent}`;
        }
      }
      const finalContent = `${targetFileContent}`;
      await this.app.vault.adapter.write(targetFilePath, finalContent);
      let aiResponse = "";
      for await (const chunk of this.sendTimedQueryToAI(promptContent, targetFileContent + additionalContent)) {
        await this.app.vault.adapter.append(targetFilePath, chunk);
        aiResponse += chunk;
      }
      if (this.settings.isFlomoEnabled && this.settings.flomoApiKey) {
        await this.sendToFlomo(aiResponse);
      }
      new import_obsidian2.Notice(`Timed task executed: ${query.time}.`);
    } catch (error) {
      console.error("Error executing timed query:", error);
      new import_obsidian2.Notice(`Timed task execution failed: ${query.time}`);
    } finally {
      this.isTriggerGenerating = false;
      this.processNextTrigger();
    }
  }
  async processNextTrigger() {
    if (this.triggerQueue.length > 0) {
      const nextQuery = this.triggerQueue.shift();
      if (nextQuery) {
        await this.executeTimedQuery(nextQuery);
      }
    }
  }
  async sendToFlomo(content) {
    try {
      const flomoApiUrl = this.settings.flomoApiKey;
      if (!flomoApiUrl.startsWith("https://flomoapp.com/iwh/")) {
        new import_obsidian2.Notice("Flomo API URL format is incorrect.");
        return;
      }
      const response = await (0, import_obsidian2.requestUrl)({
        url: flomoApiUrl,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ content })
      });
      if (response.status === 200) {
        new import_obsidian2.Notice("Send Flomo Success");
      } else {
        let errorMsg = `HTTP\u9519\u8BEF ${response.status}`;
        try {
          const errorData = await response.json();
          errorMsg += `: ${JSON.stringify(errorData)}`;
          console.error("Flomo\u53D1\u9001\u5931\u8D25:", errorMsg);
        } catch (e) {
          const errorText = response.text;
          errorMsg += `: ${errorText.substring(0, 100)}...`;
          console.error("Flomo\u53D1\u9001\u5931\u8D25:", errorMsg);
        }
        new import_obsidian2.Notice("Send Flomo Failed");
      }
    } catch (error) {
      console.error("Flomo\u53D1\u9001\u5931\u8D25:", error);
      new import_obsidian2.Notice("Send Flomo Failed");
    }
  }
  async *sendTimedQueryToAI(prompt, content) {
    if (!this.settings.deepseekApiKey) {
      throw new Error("Deepseek API Key not set");
    }
    const messages = [
      { role: "system", content: prompt },
      { role: "user", content: `\u8BF7\u5206\u6790\u4EE5\u4E0B\u5185\u5BB9\uFF1A

${content}` }
    ];
    const uniqueRequestId = this.generateSessionId();
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.deepseek.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.deepseekApiKey}`
      },
      body: JSON.stringify({
        model: this.settings.deepseekModel,
        messages,
        temperature: 0.7,
        top_p: 0.95,
        stream: true,
        user: uniqueRequestId
      })
    });
    if (!response.text) {
      throw new Error("Response body is not a readable stream");
    }
    const reader = response.text;
    const decoder = new TextDecoder("utf-8");
    let done = false;
  }
  async createDefaultPromptFile() {
    const filePath = this.settings.defaultPromptFile;
    const exists = await this.app.vault.adapter.exists(filePath);
    if (!exists) {
      const defaultContent = `\u4F60\u662F\u4E00\u4E2A\u4EFB\u52A1\u7BA1\u7406\u4E0E\u4E8B\u9879\u5206\u6790\u7684\u4E13\u5BB6\uFF0C\u8BF7\u534F\u52A9\u6211\u8FDB\u884C\u5206\u6790\u3002`;
      await this.app.vault.create(filePath, defaultContent);
      console.log(`[TaskAI] Created default prompt file: ${filePath}`);
      return true;
    }
    return false;
  }
  async getDailyNotesConfigFromFile() {
    try {
      const configPath = ".obsidian/config";
      if (!await this.app.vault.adapter.exists(configPath)) {
        console.error("config \u6587\u4EF6\u4E0D\u5B58\u5728");
        return null;
      }
      const configContent = await this.app.vault.adapter.read(configPath);
      const config = JSON.parse(configContent);
      return config["daily-notes"] || null;
    } catch (error) {
      console.error("\u8BFB\u53D6\u6216\u89E3\u6790 config \u6587\u4EF6\u5931\u8D25:", error);
      return null;
    }
  }
};
